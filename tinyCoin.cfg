############ TINY COIN ################

### NETWORK CONFIGURATION CONSTANTS ###

CYCLES 10^8
SIZE 500 #500
DEGREE 5

MAX_INITIAL_BITCOINS 101
MAX_TRANS_PER_BLOCK 100
PROB_GENERATE_TRANS 1

LATENCY = 5
BLOCK_REWARD 10
EXTRA_LATENCY_PER_TRANS 0
EXTRA_REWARD_PER_TRANS 1

ORACLE_MEAN 1000
ORACLE_VARIANCE 30;

# Probability to CHOOSE one type of miner
PROB_CPU_POWER 5
PROB_GPU_POWER 15
PROB_FPGA_POWER 45
PROB_ASIC_POWER 100

# Probability to CREATE one type of miner or normal node
PROB_NORMAL 75
PROB_CPU 25
PROB_GPU 50
PROB_FPGA 75
PROB_ASIC 100

# Probability to be SELFISH
PROB_SELFISH 30
MAX_SELFISH 100


#################################

random.seed 1234567890
simulation.endtime CYCLES
simulation.logtime 10^6
simulation.experiments 1

network.size SIZE

# Keep latency fixed (apart from extra delays due to block dim)
protocol.tr UniformRandomTransport # NEED TO BUILD A CUSTOM ONE
{
	mindelay LATENCY
	maxdelay LATENCY
}

protocol.tinyProtocol TinyNode
{
	transport tr
	step 1
}

control.oracle Oracle
{
	protocol tinyProtocol
	step 1
	#step 100
	#from 100
	#until 201
	#step 100 
}


# Vedere topologia di bitcoin graph e invocare un connettore opportuno (o implementarne uno (see doc)..)
init.rnd WireKOut
init.rnd.undir true
init.rnd.k DEGREE
init.rnd.protocol tinyProtocol

init.sch CDScheduler 
{
	protocol tinyProtocol	
}

init.create TinyCoinInitialiser 
{
	protocol tinyProtocol 
}

control.observer TinyNodeObserver
{
	protocol tinyProtocol
	step 10
	from 10
	#at CYCLES
	#FINAL
}

#control.maintain ChordMaintainer
#{
#	step 10500
#}


#control.lnkob LinkObserver
#{
# protocol my 
# FINAL 
# at CYCLES
#}