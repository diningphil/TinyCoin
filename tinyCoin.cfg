############ TINY COIN ################

### NETWORK CONFIGURATION CONSTANTS ###

CYCLES 10000 #10^6
SIZE 100 #1000000
DEGREE 5

MAX_INITIAL_BITCOINS 101
MAX_TRANS_PER_BLOCK 10
PROB_GENERATE_TRANS 10

LATENCY = 1
BLOCK_REWARD 10
EXTRA_LATENCY_PER_TRANS 1
EXTRA_REWARD_PER_TRANS 1

ORACLE_MEAN 100 
ORACLE_VARIANCE 10;

# Probability to CHOOSE one type of miner
PROB_CPU_POWER 5
PROB_GPU_POWER 15
PROB_FPGA_POWER 45
PROB_ASIC_POWER 100

# Probability to CREATE one type of miner or normal node
PROB_NORMAL 75
PROB_CPU 25
PROB_GPU 50
PROB_FPGA 75
PROB_ASIC 100
     
#################################

random.seed 1234567890
simulation.endtime CYCLES
simulation.logtime 10^6
simulation.experiments 1

network.size SIZE

# Keep latency fixed (apart from extra delays due to block dim)
protocol.tr UniformRandomTransport # NEED TO BUILD A CUSTOM ONE
{
	mindelay LATENCY
	maxdelay LATENCY
}

protocol.tinyProtocol TinyNode
{
	transport tr
	step 1
}

control.oracle Oracle
{
	protocol tinyProtocol
	step 1
	#step 100
	#from 100
	#until 201
	#step 100 
}


# Vedere topologia di bitcoin graph e invocare un connettore opportuno (o implementarne uno (see doc)..)
init.rndlink WireKOut
init.rndlink.undirected true
init.rndlink.k DEGREE
init.rndlink.protocol tinyProtocol


init.sch CDScheduler 
{
	protocol tinyProtocol	
}

init.create TinyCoinInitialiser 
{
	protocol tinyProtocol 
}

#control.maintain ChordMaintainer
#{
#	step 10500
#}

#control.observer ResultObserver
#{
#	protocol my
#	#step 90000
#	at CYCLES
#	FINAL
#}

#control.lnkob LinkObserver
#{
# protocol my 
# FINAL 
# at CYCLES
#}